# N1 Parser - Full Standalone Version
# Auto-generated by build_parser_v2.sh  
# All dependencies inlined for N0 compatibility

# Token Constants & Struct
var TOKEN_ILLEGAL = 0
var TOKEN_EOF = 1
var TOKEN_IDENT = 2
var TOKEN_INT = 3
var TOKEN_FLOAT = 4
var TOKEN_STRING = 5
var TOKEN_CHAR = 6

var TOKEN_ASSIGN = 7
var TOKEN_PLUS = 8
var TOKEN_MINUS = 9
var TOKEN_BANG = 10
var TOKEN_ASTERISK = 11
var TOKEN_SLASH = 12
var TOKEN_PERCENT = 13

var TOKEN_EQ = 14
var TOKEN_NOT_EQ = 15
var TOKEN_LT = 16
var TOKEN_GT = 17
var TOKEN_LE = 18
var TOKEN_GE = 19

var TOKEN_AND = 20
var TOKEN_OR = 21
var TOKEN_BIT_AND = 22
var TOKEN_BIT_OR = 23
var TOKEN_BIT_XOR = 24
var TOKEN_BIT_NOT = 25
var TOKEN_LSHIFT = 26
var TOKEN_RSHIFT = 27

var TOKEN_COMMA = 28
var TOKEN_SEMICOLON = 29
var TOKEN_COLON = 30
var TOKEN_DOT = 31
var TOKEN_ARROW = 32

var TOKEN_LPAREN = 33
var TOKEN_RPAREN = 34
var TOKEN_LBRACE = 35
var TOKEN_RBRACE = 36
var TOKEN_LBRACKET = 37
var TOKEN_RBRACKET = 38

var TOKEN_FUNGSI = 39
var TOKEN_NATIVE = 40
var TOKEN_JIKA = 41
var TOKEN_ATAU_JIKA = 42
var TOKEN_LAINNYA = 43
var TOKEN_KEMBALIKAN = 44
var TOKEN_BENAR = 45
var TOKEN_SALAH = 46
var TOKEN_KOSONG = 47
var TOKEN_AKHIR = 48
var TOKEN_SELAMA = 49
var TOKEN_DAN = 50
var TOKEN_ATAU = 51
var TOKEN_AMBIL = 52
var TOKEN_DARI = 53
var TOKEN_BERHENTI = 54
var TOKEN_LANJUT = 55
var TOKEN_STRUKTUR = 56
var TOKEN_INTERFACE = 57
var TOKEN_VAR = 58
var TOKEN_TETAPAN = 59
var TOKEN_MAP = 60
var TOKEN_PILIH = 61
var TOKEN_KASUS = 62

struktur Token
    token_type int
    literal string
    line int
    column int
    has_leading_space bool
akhir

fungsi new_token(token_type int, literal string, line int, column int) Token
    kembalikan Token{
        token_type: token_type,
        literal: literal,
        line: line,
        column: column,
        has_leading_space: salah
    }
akhir

# AST Node Types & Structures
# ============================================================================
# Node Type Constants
# ============================================================================
var NODE_PROGRAM = 0
var NODE_VAR_STATEMENT = 1
var NODE_FUNCTION_STATEMENT = 2
var NODE_RETURN_STATEMENT = 3
var NODE_EXPRESSION_STATEMENT = 4
var NODE_BLOCK_STATEMENT = 5
var NODE_IF_EXPRESSION = 6
var NODE_IDENTIFIER = 7
var NODE_INTEGER_LITERAL = 8
var NODE_FLOAT_LITERAL = 9
var NODE_STRING_LITERAL = 10
var NODE_BOOLEAN_LITERAL = 11
var NODE_ARRAY_LITERAL = 12
var NODE_HASH_LITERAL = 13
var NODE_FUNCTION_LITERAL = 14
var NODE_PREFIX_EXPRESSION = 15
var NODE_INFIX_EXPRESSION = 16
var NODE_CALL_EXPRESSION = 17
var NODE_INDEX_EXPRESSION = 18
var NODE_MEMBER_EXPRESSION = 19
var NODE_ASSIGNMENT_EXPRESSION = 20
var NODE_SWITCH_STATEMENT = 21
var NODE_CASE_CLAUSE = 22
var NODE_WHILE_STATEMENT = 23
var NODE_STRUCT_STATEMENT = 24
var NODE_STRUCT_LITERAL = 25
var NODE_IMPORT_STATEMENT = 26
var NODE_INTERFACE_STATEMENT = 27
var NODE_BREAK_STATEMENT = 28
var NODE_CONTINUE_STATEMENT = 29
var NODE_CHAR_LITERAL = 30
var NODE_NULL_LITERAL = 31

# ============================================================================
# Base Node Structure
# ============================================================================
struktur Node
    node_type int
    token_literal string
    line int
    column int
akhir

# ============================================================================
# Statement Nodes
# ============================================================================
struktur VarStatement
    base Node
    name string
    value_type string  # Optional type annotation
    has_value bool
    value_literal string
    value_token_type int
    # Note: value would be an Expression node
akhir

struktur FunctionStatement
    base Node
    name string
    parameters_count int
    return_type string
    # Note: parameters and body would be arrays/nodes
akhir

struktur ReturnStatement
    base Node
    has_value bool
    # Note: return_value would be an Expression node
akhir

struktur ExpressionStatement
    base Node
    # Note: expression would be an Expression node
akhir

struktur BlockStatement
    base Node
    statements_count int
    # Note: statements would be an array of Statement nodes
akhir

# ============================================================================
# Program Node (Root)
# ============================================================================
struktur Program
    base Node
    statements_count int
    var_statements_count int
    var_statement VarStatement
    has_var_statement bool
    # Note: In a real implementation, we'd have an array of statements
    # For simplicity, we'll track count and process statements individually
akhir

# ============================================================================
# Expression Nodes
# ============================================================================
struktur Identifier
    base Node
    value string
akhir

struktur IntegerLiteral
    base Node
    value int
akhir

struktur FloatLiteral
    base Node
    value_str string  # Store as string for now
akhir

struktur StringLiteral
    base Node
    value string
akhir

struktur BooleanLiteral
    base Node
    value bool
akhir

struktur CharLiteral
    base Node
    value int
akhir

struktur NullLiteral
    base Node
akhir

struktur PrefixExpression
    base Node
    operator string
    # Note: right would be an Expression node
akhir

struktur InfixExpression
    base Node
    operator string
    # Note: left and right would be Expression nodes
akhir

struktur IfExpression
    base Node
    # Note: condition, consequence, alternative would be nodes
    has_alternative bool
akhir

struktur CallExpression
    base Node
    # Note: function and arguments would be nodes
    arguments_count int
akhir

struktur IndexExpression
    base Node
    # Note: left and index would be Expression nodes
akhir

struktur MemberExpression
    base Node
    member_name string
    # Note: object would be an Expression node
akhir

# ============================================================================
# Switch/Case Nodes (pilih/kasus)
# ============================================================================
struktur CaseClause
    base Node
    values_count int      # Number of values (for multi-case: kasus 1, 2, 3:)
    v0 int                # First value (simplified - stores int for now)
    v1 int                # Second value
    v2 int                # Third value
    v3 int                # Fourth value
    has_body bool
akhir

struktur SwitchStatement
    base Node
    cases_count int       # Number of case clauses
    has_default bool      # Has lainnya block
akhir

# ============================================================================
# While Statement
# ============================================================================
struktur WhileStatement
    base Node
    has_body bool
akhir

# ============================================================================
# Struct Statement
# ============================================================================
struktur StructStatement
    base Node
    name string
    fields_count int
akhir

# ============================================================================
# Import Statement
# ============================================================================
struktur ImportStatement
    base Node
    path string
akhir

# ============================================================================
# Break/Continue Statements
# ============================================================================
struktur BreakStatement
    base Node
akhir

struktur ContinueStatement
    base Node
akhir

# ============================================================================
# Node Constructors
# ============================================================================
fungsi MakeNode(node_type int, literal string, line int, column int) Node
    kembalikan Node{node_type: node_type, token_literal: literal, line: line, column: column}
akhir

fungsi MakeProgram() Program
    var base = MakeNode(NODE_PROGRAM, "program", 1, 1)
    var stmt = MakeVarStatement("-", "-", 1, 1)
    kembalikan Program{
        base: base,
        statements_count: 0,
        var_statements_count: 0,
        var_statement: stmt,
        has_var_statement: salah
    }
akhir

fungsi MakeIdentifier(name string, line int, column int) Identifier
    var base = MakeNode(NODE_IDENTIFIER, name, line, column)
    kembalikan Identifier{base: base, value: name}
akhir

fungsi MakeIntegerLiteral(value int, literal string, line int, column int) IntegerLiteral
    var base = MakeNode(NODE_INTEGER_LITERAL, literal, line, column)
    kembalikan IntegerLiteral{base: base, value: value}
akhir

fungsi MakeFloatLiteral(value_str string, line int, column int) FloatLiteral
    var base = MakeNode(NODE_FLOAT_LITERAL, value_str, line, column)
    kembalikan FloatLiteral{base: base, value_str: value_str}
akhir

fungsi MakeStringLiteral(value string, line int, column int) StringLiteral
    var base = MakeNode(NODE_STRING_LITERAL, value, line, column)
    kembalikan StringLiteral{base: base, value: value}
akhir

fungsi MakeBooleanLiteral(value bool, literal string, line int, column int) BooleanLiteral
    var base = MakeNode(NODE_BOOLEAN_LITERAL, literal, line, column)
    kembalikan BooleanLiteral{base: base, value: value}
akhir

fungsi MakeCharLiteral(value int, literal string, line int, column int) CharLiteral
    var base = MakeNode(NODE_CHAR_LITERAL, literal, line, column)
    kembalikan CharLiteral{base: base, value: value}
akhir

fungsi MakeNullLiteral(line int, column int) NullLiteral
    var base = MakeNode(NODE_NULL_LITERAL, "null", line, column)
    kembalikan NullLiteral{base: base}
akhir

fungsi MakeVarStatement(name string, type_str string, line int, column int) VarStatement
    var base = MakeNode(NODE_VAR_STATEMENT, "var", line, column)
    kembalikan VarStatement{base: base, name: name, value_type: type_str, has_value: salah, value_literal: "-", value_token_type: 0}
akhir

fungsi MakePrefixExpression(operator string, line int, column int) PrefixExpression
    var base = MakeNode(NODE_PREFIX_EXPRESSION, operator, line, column)
    kembalikan PrefixExpression{base: base, operator: operator}
akhir

fungsi make_infix_expression(operator string, line int, column int) InfixExpression
    var base = MakeNode(NODE_INFIX_EXPRESSION, operator, line, column)
    kembalikan InfixExpression{base: base, operator: operator}
akhir

fungsi make_case_clause(line int, column int) CaseClause
    var base = MakeNode(NODE_CASE_CLAUSE, "kasus", line, column)
    kembalikan CaseClause{base: base, values_count: 0, v0: 0, v1: 0, v2: 0, v3: 0, has_body: salah}
akhir

fungsi case_add_value(c CaseClause, val int) CaseClause
    jika c.values_count == 0
        c.v0 = val
    akhir
    jika c.values_count == 1
        c.v1 = val
    akhir
    jika c.values_count == 2
        c.v2 = val
    akhir
    jika c.values_count == 3
        c.v3 = val
    akhir
    c.values_count = c.values_count + 1
    kembalikan c
akhir

fungsi make_switch_statement(line int, column int) SwitchStatement
    var base = MakeNode(NODE_SWITCH_STATEMENT, "pilih", line, column)
    kembalikan SwitchStatement{base: base, cases_count: 0, has_default: salah}
akhir

fungsi make_while_statement(line int, column int) WhileStatement
    var base = MakeNode(NODE_WHILE_STATEMENT, "selama", line, column)
    kembalikan WhileStatement{base: base, has_body: salah}
akhir

fungsi make_struct_statement(name string, line int, column int) StructStatement
    var base = MakeNode(NODE_STRUCT_STATEMENT, "struktur", line, column)
    kembalikan StructStatement{base: base, name: name, fields_count: 0}
akhir

fungsi make_import_statement(path string, line int, column int) ImportStatement
    var base = MakeNode(NODE_IMPORT_STATEMENT, "ambil", line, column)
    kembalikan ImportStatement{base: base, path: path}
akhir

fungsi make_break_statement(line int, column int) BreakStatement
    var base = MakeNode(NODE_BREAK_STATEMENT, "putus", line, column)
    kembalikan BreakStatement{base: base}
akhir

fungsi make_continue_statement(line int, column int) ContinueStatement
    var base = MakeNode(NODE_CONTINUE_STATEMENT, "lanjut", line, column)
    kembalikan ContinueStatement{base: base}
akhir

# ============================================================================
# Node Type to String
# ============================================================================
fungsi node_type_string(node_type int) string
    jika node_type == NODE_PROGRAM
        kembalikan "Program"
    akhir
    jika node_type == NODE_VAR_STATEMENT
        kembalikan "VarStatement"
    akhir
    jika node_type == NODE_FUNCTION_STATEMENT
        kembalikan "FunctionStatement"
    akhir
    jika node_type == NODE_RETURN_STATEMENT
        kembalikan "ReturnStatement"
    akhir
    jika node_type == NODE_EXPRESSION_STATEMENT
        kembalikan "ExpressionStatement"
    akhir
    jika node_type == NODE_BLOCK_STATEMENT
        kembalikan "BlockStatement"
    akhir
    jika node_type == NODE_IF_EXPRESSION
        kembalikan "IfExpression"
    akhir
    jika node_type == NODE_IDENTIFIER
        kembalikan "Identifier"
    akhir
    jika node_type == NODE_INTEGER_LITERAL
        kembalikan "IntegerLiteral"
    akhir
    jika node_type == NODE_FLOAT_LITERAL
        kembalikan "FloatLiteral"
    akhir
    jika node_type == NODE_STRING_LITERAL
        kembalikan "StringLiteral"
    akhir
    jika node_type == NODE_BOOLEAN_LITERAL
        kembalikan "BooleanLiteral"
    akhir
    jika node_type == NODE_CHAR_LITERAL
        kembalikan "CharLiteral"
    akhir
    jika node_type == NODE_NULL_LITERAL
        kembalikan "NullLiteral"
    akhir
    jika node_type == NODE_ARRAY_LITERAL
        kembalikan "ArrayLiteral"
    akhir
    jika node_type == NODE_HASH_LITERAL
        kembalikan "HashLiteral"
    akhir
    jika node_type == NODE_FUNCTION_LITERAL
        kembalikan "FunctionLiteral"
    akhir
    jika node_type == NODE_PREFIX_EXPRESSION
        kembalikan "PrefixExpression"
    akhir
    jika node_type == NODE_INFIX_EXPRESSION
        kembalikan "InfixExpression"
    akhir
    jika node_type == NODE_CALL_EXPRESSION
        kembalikan "CallExpression"
    akhir
    jika node_type == NODE_INDEX_EXPRESSION
        kembalikan "IndexExpression"
    akhir
    jika node_type == NODE_MEMBER_EXPRESSION
        kembalikan "MemberExpression"
    akhir
    jika node_type == NODE_ASSIGNMENT_EXPRESSION
        kembalikan "AssignmentExpression"
    akhir
    kembalikan "Unknown"
akhir

# ============================================================================
# AST Visitor Pattern (Simplified)
# ============================================================================
fungsi visit_node(node Node) void
    native_print("Visiting ")
    native_print(node_type_string(node.node_type))
    native_print(" at line ")
    native_print_int(node.line)
    native_print(", column ")
    native_print_int(node.column)
    native_print("\n")
akhir

# ============================================================================
# AST Utilities
# ============================================================================
fungsi print_identifier(ident Identifier) void
    native_print("Identifier: ")
    native_print(ident.value)
    native_print(" (")
    native_print_int(ident.base.line)
    native_print(":")
    native_print_int(ident.base.column)
    native_print(")\n")
akhir

fungsi print_integer_literal(lit IntegerLiteral) void
    native_print("IntegerLiteral: ")
    native_print_int(lit.value)
    native_print(" (")
    native_print_int(lit.base.line)
    native_print(":")
    native_print_int(lit.base.column)
    native_print(")\n")
akhir

fungsi print_string_literal(lit StringLiteral) void
    native_print("StringLiteral: \"")
    native_print(lit.value)
    native_print("\" (")
    native_print_int(lit.base.line)
    native_print(":")
    native_print_int(lit.base.column)
    native_print(")\n")
akhir

fungsi print_boolean_literal(lit BooleanLiteral) void
    native_print("BooleanLiteral: ")
    jika lit.value
        native_print("benar")
    lainnya
        native_print("salah")
    akhir
    native_print(" (")
    native_print_int(lit.base.line)
    native_print(":")
    native_print_int(lit.base.column)
    native_print(")\n")
akhir

# Parser Implementation
# N1 Parser Implementation (Simplified)
# Port dari N0 pkg/parser/parser.go

# Import dependencies

# ============================================================================
# Precedence Constants
# ============================================================================
var PRECEDENCE_LOWEST = 1
var PRECEDENCE_EQUALS = 2      # ==
var PRECEDENCE_LESSGREATER = 3 # > or <
var PRECEDENCE_SUM = 4         # +
var PRECEDENCE_PRODUCT = 5     # *
var PRECEDENCE_PREFIX = 6      # -X or !X
var PRECEDENCE_CALL = 7        # myFunction(X)

# ============================================================================
# Parser Structure
# ============================================================================
struktur Parser
    lexer Lexer
    current_token Token
    peek_token Token
    errors_count int
    # Note: In a real implementation, we'd have an array of error messages
akhir

# ============================================================================
# Parser Constructor
# ============================================================================
fungsi NewParser(l Lexer) Parser
    var p = Parser{lexer: l, errors_count: 0, current_token: new_token(0, "", 0, 0), peek_token: new_token(0, "", 0, 0)}

    # Read two tokens, so current_token and peek_token are both set
    ParserNextToken(p)
    ParserNextToken(p)

    kembalikan p
akhir

# ============================================================================
# Token Management
# ============================================================================
fungsi ParserNextToken(p Parser) void
    p.current_token = p.peek_token
    p.peek_token = LexerNextToken(p.lexer)
akhir

fungsi ParserCurrentTokenIs(p Parser, token_type int) bool
    kembalikan p.current_token.token_type == token_type
akhir

fungsi ParserPeekTokenIs(p Parser, token_type int) bool
    kembalikan p.peek_token.token_type == token_type
akhir

fungsi ParserExpectPeek(p Parser, token_type int) bool
    jika ParserPeekTokenIs(p, token_type) == benar
        ParserNextToken(p)
        kembalikan benar
    lainnya
        # Add error (simplified)
        p.errors_count = p.errors_count + 1
        kembalikan salah
    akhir
akhir

# ============================================================================
# Precedence Helpers
# ============================================================================
fungsi GetTokenPrecedence(token_type int) int
    jika token_type == TOKEN_EQ
        kembalikan PRECEDENCE_EQUALS
    akhir
    jika token_type == TOKEN_NOT_EQ
        kembalikan PRECEDENCE_EQUALS
    akhir
    jika token_type == TOKEN_LT
        kembalikan PRECEDENCE_LESSGREATER
    akhir
    jika token_type == TOKEN_GT
        kembalikan PRECEDENCE_LESSGREATER
    akhir
    jika token_type == TOKEN_LE
        kembalikan PRECEDENCE_LESSGREATER
    akhir
    jika token_type == TOKEN_GE
        kembalikan PRECEDENCE_LESSGREATER
    akhir
    jika token_type == TOKEN_PLUS
        kembalikan PRECEDENCE_SUM
    akhir
    jika token_type == TOKEN_MINUS
        kembalikan PRECEDENCE_SUM
    akhir
    jika token_type == TOKEN_SLASH
        kembalikan PRECEDENCE_PRODUCT
    akhir
    jika token_type == TOKEN_ASTERISK
        kembalikan PRECEDENCE_PRODUCT
    akhir
    jika token_type == TOKEN_PERCENT
        kembalikan PRECEDENCE_PRODUCT
    akhir
    jika token_type == TOKEN_LPAREN
        kembalikan PRECEDENCE_CALL
    akhir
    kembalikan PRECEDENCE_LOWEST
akhir

fungsi ParserPeekPrecedence(p Parser) int
    kembalikan GetTokenPrecedence(p.peek_token.token_type)
akhir

fungsi ParserCurrentPrecedence(p Parser) int
    kembalikan GetTokenPrecedence(p.current_token.token_type)
akhir

# ============================================================================
# Expression Parsing
# ============================================================================
fungsi ParseIdentifier(p Parser) Identifier
    kembalikan MakeIdentifier(p.current_token.literal, p.current_token.line, p.current_token.column)
akhir

fungsi ParseIntegerLiteral(p Parser) IntegerLiteral
    # Simplified integer parsing - convert string to int
    var value = StringToInt(p.current_token.literal)
    kembalikan MakeIntegerLiteral(value, p.current_token.literal, p.current_token.line, p.current_token.column)
akhir

fungsi ParseStringLiteral(p Parser) StringLiteral
    kembalikan MakeStringLiteral(p.current_token.literal, p.current_token.line, p.current_token.column)
akhir

fungsi ParseBooleanLiteral(p Parser) BooleanLiteral
    var value = ParserCurrentTokenIs(p, TOKEN_BENAR)
    kembalikan MakeBooleanLiteral(value, p.current_token.literal, p.current_token.line, p.current_token.column)
akhir

fungsi ParseFloatLiteral(p Parser) FloatLiteral
    kembalikan MakeFloatLiteral(p.current_token.literal, p.current_token.line, p.current_token.column)
akhir

fungsi ParseCharLiteral(p Parser) CharLiteral
    var value = lexer.CharToAscii(p.current_token.literal)
    kembalikan MakeCharLiteral(value, p.current_token.literal, p.current_token.line, p.current_token.column)
akhir

fungsi ParseNullLiteral(p Parser) NullLiteral
    kembalikan MakeNullLiteral(p.current_token.line, p.current_token.column)
akhir

# ============================================================================
# Simplified Expression Parsing
# ============================================================================
fungsi ParsePrefixExpression(p Parser) PrefixExpression
    var expr = MakePrefixExpression(p.current_token.literal, p.current_token.line, p.current_token.column)

    ParserNextToken(p)

    # Note: In a real implementation, we'd parse the right expression here
    # For now, we just create the prefix expression structure

    kembalikan expr
akhir

# ============================================================================
# Statement Parsing
# ============================================================================
fungsi ParseVarStatement(p Parser) VarStatement
    var line = p.current_token.line
    var column = p.current_token.column

    jika ParserExpectPeek(p, TOKEN_IDENT) == salah
        # Error: expected identifier
        kembalikan MakeVarStatement("-", "-", line, column)
    akhir

    var name = p.current_token.literal

    # Check for optional type annotation
    var type_str = "-"
    jika ParserPeekTokenIs(p, TOKEN_COLON) == benar
        ParserNextToken(p)  # consume ':'
        jika ParserExpectPeek(p, TOKEN_IDENT) == benar
            type_str = p.current_token.literal
        akhir
    akhir

    var stmt = MakeVarStatement(name, type_str, line, column)

    # Check for assignment
    jika ParserPeekTokenIs(p, TOKEN_ASSIGN) == benar
        ParserNextToken(p)  # consume '='
        ParserNextToken(p)  # move to value
        stmt.has_value = benar
        stmt.value_literal = p.current_token.literal
        stmt.value_token_type = p.current_token.token_type

        # Note: In a real implementation, we'd parse the expression here
    akhir

    # Skip to semicolon or end of statement
    var should_continue = benar
    selama should_continue == benar
        jika ParserCurrentTokenIs(p, TOKEN_SEMICOLON) == benar
            should_continue = salah
        lainnya
            jika ParserCurrentTokenIs(p, TOKEN_EOF) == benar
                should_continue = salah
            lainnya
                ParserNextToken(p)
            akhir
        akhir
    akhir

    kembalikan stmt
akhir

# ============================================================================
# Program Parsing
# ============================================================================
fungsi ParseProgram(p Parser) Program
    var program = MakeProgram()

    selama ParserCurrentTokenIs(p, TOKEN_EOF) == salah
        jika ParserCurrentTokenIs(p, TOKEN_VAR) == benar
            var stmt = ParseVarStatement(p)
            program.statements_count = program.statements_count + 1
            program.var_statements_count = program.var_statements_count + 1
            program.var_statement = stmt
            program.has_var_statement = benar

            # Print parsed statement for debugging
            native_print("Parsed VarStatement: ")
            native_print(stmt.name)
            jika stmt.value_type != "-"
                native_print(" : ")
                native_print(stmt.value_type)
            akhir
            jika stmt.has_value == benar
                native_print(" = <expression>")
            akhir
            native_print("\n")
        akhir

        ParserNextToken(p)
    akhir

    kembalikan program
akhir

# ============================================================================
# Utility Functions
# ============================================================================
fungsi StringToInt(s string) int
    var length = panjang(s)
    jika length == 0
        kembalikan 0
    akhir

    var i = 0
    var sign = 1
    jika substring(s, 0, 1) == "-"
        sign = -1
        i = 1
    akhir

    var result = 0
    selama i < length
        var ch = substring(s, i, i + 1)
        jika ch == "0"
            result = result * 10 + 0
        atau_jika ch == "1"
            result = result * 10 + 1
        atau_jika ch == "2"
            result = result * 10 + 2
        atau_jika ch == "3"
            result = result * 10 + 3
        atau_jika ch == "4"
            result = result * 10 + 4
        atau_jika ch == "5"
            result = result * 10 + 5
        atau_jika ch == "6"
            result = result * 10 + 6
        atau_jika ch == "7"
            result = result * 10 + 7
        atau_jika ch == "8"
            result = result * 10 + 8
        atau_jika ch == "9"
            result = result * 10 + 9
        lainnya
            kembalikan 0
        akhir
        i = i + 1
    akhir

    kembalikan result * sign
akhir

# ============================================================================
# Parser Error Reporting
# ============================================================================
fungsi ParserHasErrors(p Parser) bool
    kembalikan p.errors_count > 0
akhir

fungsi ParserPrintErrors(p Parser) void
    jika p.errors_count > 0
        native_print("Parser has ")
        native_print_int(p.errors_count)
        native_print(" error(s)\n")
    lainnya
        native_print("No parser errors\n")
    akhir
akhir
