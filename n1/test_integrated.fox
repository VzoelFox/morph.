# N1 Integrated Test - Full Pipeline
# Testing lexer -> parser -> type checker integration

# Import all components
ambil "types"
ambil "token"
ambil "lexer"
ambil "ast"
ambil "parser"
ambil "checker"

fungsi main() void
    native_print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n")
    native_print("â•‘     N1 Integrated Pipeline Test     â•‘\n")
    native_print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n")

    # Test 1: Complete Pipeline - Simple Variable
    native_print("=== Test 1: Simple Variable Declaration ===\n")
    var input1 = "var x = 42"
    
    native_print("Input: ")
    native_print(input1)
    native_print("\n\n")
    
    # Step 1: Lexical Analysis
    native_print("Step 1: Lexical Analysis\n")
    var l1 = new_lexer(input1)
    var token_count = 0
    
    selama benar
        var tok = lexer_next_token(l1)
        native_print("  ")
        native_print(token_type_string(tok.token_type))
        native_print(": '")
        native_print(tok.literal)
        native_print("'\n")
        
        token_count = token_count + 1
        jika tok.token_type == TOKEN_EOF atau token_count > 10
            putus
        akhir
    akhir
    
    # Step 2: Parsing
    native_print("\nStep 2: Parsing\n")
    var l1_fresh = new_lexer(input1)
    var p1 = new_parser(l1_fresh)
    var program1 = parser_parse_program(p1)
    
    native_print("  Parsed ")
    native_print_int(program1.statements_count)
    native_print(" statement(s)\n")
    parser_print_errors(p1)
    
    # Step 3: Type Checking
    native_print("\nStep 3: Type Checking\n")
    var c1 = new_checker()
    check_program(c1, program1)
    
    native_print("\n==================================================\n\n")

    # Test 2: Type Annotation
    native_print("=== Test 2: Variable with Type Annotation ===\n")
    var input2 = "var name : string = \"hello\""
    
    native_print("Input: ")
    native_print(input2)
    native_print("\n\n")
    
    # Full pipeline
    var l2 = new_lexer(input2)
    var p2 = new_parser(l2)
    var program2 = parser_parse_program(p2)
    var c2 = new_checker()
    check_program(c2, program2)
    
    native_print("\n==================================================\n\n")

    # Test 3: Type System Validation
    native_print("=== Test 3: Type System Validation ===\n")
    
    # Test type operations
    var int_t = int_type()
    var string_t = string_type()
    var bool_t = bool_type()
    
    native_print("Type Creation:\n")
    native_print("  int: ")
    native_print(kind_to_string(int_t.kind))
    native_print("\n")
    native_print("  string: ")
    native_print(kind_to_string(string_t.kind))
    native_print("\n")
    native_print("  bool: ")
    native_print(kind_to_string(bool_t.kind))
    native_print("\n")
    
    # Test binary operations
    native_print("\nBinary Operations:\n")
    var add_result = type_binary_op(int_t, "+", int_t)
    native_print("  int + int = ")
    jika add_result.has_error
        native_print("ERROR: ")
        native_print(add_result.error_msg)
    lainnya
        native_print(kind_to_string(add_result.result.kind))
    akhir
    native_print("\n")
    
    var concat_result = type_binary_op(string_t, "+", string_t)
    native_print("  string + string = ")
    jika concat_result.has_error
        native_print("ERROR: ")
        native_print(concat_result.error_msg)
    lainnya
        native_print(kind_to_string(concat_result.result.kind))
    akhir
    native_print("\n")
    
    var invalid_result = type_binary_op(int_t, "+", string_t)
    native_print("  int + string = ")
    jika invalid_result.has_error
        native_print("ERROR (expected): ")
        native_print(invalid_result.error_msg)
    lainnya
        native_print(kind_to_string(invalid_result.result.kind))
    akhir
    native_print("\n")
    
    native_print("\n==================================================\n\n")

    # Test 4: AST Node Creation and Traversal
    native_print("=== Test 4: AST Node Creation ===\n")
    
    var ident = make_identifier("test_variable", 1, 10)
    print_identifier(ident)
    
    var int_lit = make_integer_literal(123, "123", 2, 5)
    print_integer_literal(int_lit)
    
    var str_lit = make_string_literal("hello world", 3, 15)
    print_string_literal(str_lit)
    
    var bool_lit = make_boolean_literal(benar, "benar", 4, 20)
    print_boolean_literal(bool_lit)
    
    native_print("\n==================================================\n\n")

    # Test 5: Error Handling
    native_print("=== Test 5: Error Handling ===\n")
    
    var c_error = new_checker()
    
    # Test type compatibility
    native_print("Testing type compatibility:\n")
    var compat1 = check_assignment_compatibility(c_error, int_t, int_t)
    native_print("  int -> int: ")
    jika compat1
        native_print("COMPATIBLE\n")
    lainnya
        native_print("INCOMPATIBLE\n")
    akhir
    
    var compat2 = check_assignment_compatibility(c_error, int_t, string_t)
    native_print("  string -> int: ")
    jika compat2
        native_print("COMPATIBLE\n")
    lainnya
        native_print("INCOMPATIBLE (expected)\n")
    akhir
    
    # Test built-in function checking
    native_print("\nTesting built-in functions:\n")
    var builtin1 = check_builtin_function(c_error, "native_print", 1)
    native_print("  native_print(1 arg): ")
    native_print(kind_to_string(builtin1.kind))
    native_print("\n")
    
    var builtin2 = check_builtin_function(c_error, "panjang", 1)
    native_print("  panjang(1 arg): ")
    native_print(kind_to_string(builtin2.kind))
    native_print("\n")
    
    var builtin3 = check_builtin_function(c_error, "unknown_func", 0)
    native_print("  unknown_func(0 args): ")
    native_print(kind_to_string(builtin3.kind))
    native_print(" (expected error)\n")
    
    native_print("\nTotal errors in error test: ")
    native_print_int(c_error.errors_count)
    native_print("\n")
    
    native_print("\n==================================================\n\n")

    # Summary
    native_print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n")
    native_print("â•‘           PIPELINE SUMMARY           â•‘\n")
    native_print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
    native_print("âœ“ Lexer: Tokenization working\n")
    native_print("âœ“ Parser: AST generation working\n")
    native_print("âœ“ Type System: Type operations working\n")
    native_print("âœ“ Checker: Basic type checking working\n")
    native_print("âœ“ Error Handling: Error detection working\n")
    native_print("âœ“ Integration: Full pipeline functional\n\n")
    
    native_print("ğŸ‰ N1 COMPILER FOUNDATION COMPLETE! ğŸ‰\n")
    native_print("\nNext Phase: Advanced Features\n")
    native_print("- Function definitions and calls\n")
    native_print("- Struct types and interfaces\n")
    native_print("- Array and map operations\n")
    native_print("- Control flow (if/while/for)\n")
    native_print("- Module system integration\n")
akhir
